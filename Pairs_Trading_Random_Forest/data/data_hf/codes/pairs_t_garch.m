    %% Top 5, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 5;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)
	
A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c0.mat');

    %% Top 5, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 5;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c1.mat');

    %% Top 5, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 5;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p5c2.mat');

    %% Top 10, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 10;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c0.mat');

    %% Top 10, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 10;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c1.mat');

    %% Top 10, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 10;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p10c2.mat');

    %% Top 15, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 15;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c0.mat');

    %% Top 15, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 15;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c1.mat');

    %% Top 15, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 15;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p15c2.mat');

    %% Top 20, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 20;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c0.mat');

    %% Top 20, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 20;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c1.mat');

    %% Top 20, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 20;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p20c2.mat');

    %% Top 25, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 25;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c0.mat');

    %% Top 25, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 25;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c1.mat');

    %% Top 25, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 25;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p25c2.mat');

    %% Top 30, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 30;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c0.mat');

    %% Top 30, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 30;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c1.mat');

    %% Top 30, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 30;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p30c2.mat');

    %% Top 35, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 35;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c0.mat');

    %% Top 35, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 35;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c1.mat');

    %% Top 35, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 35;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p35c2.mat');

    %% Top 40, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 40;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c0.mat');

    %% Top 40, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 40;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c1.mat');

    %% Top 40, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 40;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p40c2.mat');

    %% Top 45, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 45;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c0.mat');

    %% Top 45, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 45;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c1.mat');

    %% Top 45, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 45;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p45c2.mat');

    %% Top 50, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 50;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c0.mat');

    %% Top 50, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 50;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c1.mat');

    %% Top 50, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 50;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p50c2.mat');

    %% Top 55, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 55;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c0.mat');

    %% Top 55, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 55;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c1.mat');

    %% Top 55, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 55;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p55c2.mat');

    %% Top 60, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 60;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c0.mat');

    %% Top 60, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 60;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c1.mat');

    %% Top 60, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 60;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p60c2.mat');

    %% Top 65, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 65;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c0.mat');

    %% Top 65, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 65;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c1.mat');

    %% Top 65, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 65;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p65c2.mat');

    %% Top 70, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 70;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c0.mat');

    %% Top 70, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 70;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c1.mat');

    %% Top 70, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 70;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p70c2.mat');

    %% Top 75, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 75;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c0.mat');

    %% Top 75, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 75;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c1.mat');

    %% Top 75, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 75;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p75c2.mat');

    %% Top 80, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 80;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c0.mat');

    %% Top 80, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 80;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c1.mat');

    %% Top 80, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 80;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p80c2.mat');

    %% Top 85, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 85;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c0.mat');

    %% Top 85, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 85;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c1.mat');

    %% Top 85, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 85;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p85c2.mat');

    %% Top 90, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 90;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c0.mat');

    %% Top 90, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 90;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c1.mat');

    %% Top 90, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 90;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p90c2.mat');

    %% Top 95, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 95;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c0.mat');

    %% Top 95, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 95;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c1.mat');

    %% Top 95, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 95;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p95c2.mat');

    %% Top 100, C = 0

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 100;
    trading_cost = 0; % works just with one day lag
    C = 0; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c0.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c0.mat');

    %% Top 100, C = 0.001

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 100;
    trading_cost = 0; % works just with one day lag
    C = 0.001; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c1.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c1.mat');

    %% Top 100, C = 0.002

    clear all; close all; clc; 

    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\kevinsheppard_multivariate\multivariate');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx\utility ');
    addpath('C:\Users\fsabino\Dropbox\paper1\PDS\cvx');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop'); 
    addpath('C:\Program Files\MATLAB\R2013b\toolbox\stats');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\Patton_copula_toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PTCop\ARMAX_GARCH_K_Toolbox');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\univariate');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\distributions');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\MFEToolbox\mex_source');
    addpath('C:\Users\fsabino\Dropbox\Fernando\PairsTrading_FEX\PairsTrading_FEX\m_Files');
    addpath('C:\Users\fsabino\Dropbox\Fernando\MFE\Matlab5\TOOLBOX\MATLAB\OMAT');
    addpath('C:\Users\fsabino\Dropbox\Fernando\__MACOSX\PDS\códigos');
    addpath('C:\Users\fsabino\Dropbox\Fernando\Garch');
    addpath('C:\Users\fsabino\Desktop\Fernando\dist_sq');
    addpath('C:\Users\fsabino\Desktop\Fernando\sq_mix');
    addpath('C:\Users\fsabino\Dropbox\paper_pairs_trading_realized\fillts\paper3');
    addpath('C:\Users\fsabino\Desktop\Fernando\Codes Matlab');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados');
    addpath('C:\Users\fsabino\Dropbox\pairs_trading_hf\dados\fatores_risco');
    addpath('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\data');


    % ----------------------------------------------------
    % Load in data
    % ----------------------------------------------------
    testing = 0;

    load data_hf
    load dduv_g
 
    % ddu and ddv should be between [-0.5; 0.5].
    ddu_tf(ddu_tf > 0.5) = 0.5; ddv_tf(ddv_tf > 0.5) = 0.5; 
 
    
    % ----------------------------------------------------
    % Set default values
    % ----------------------------------------------------

    [T,N]= size(Rt); % T = number of periods (days)
    % N = number of assets in the whole period
    daylag = 0;    % set whether (1, default) or not (0) signals take one day to go into effect (cf. Table 1A vs. 1B)
    wi_update = 1; % set whether (1, default) or not (0) intra-pair weights are updated when pair is open; 
                   % if not: weights stay at 50-50%
    Years = 2016 - 2009;

    no_pairs = 100;
    trading_cost = 0; % works just with one day lag
    C = 0.002; % buy/sell (percentage cost for opening and closing pairs)
    % trade_req = 0; % set whether (0) or not (2) positive trading volume is required for opening/closing a pair
    Stop_loss = -Inf ; %disp(['Stop_loss = ', num2str(Stop_loss)]);%Choose how much loss we are willing to accept on a given pair, compared to 1, i.e 0.93 = 7% stop loss
    Stop_gain = Inf;  %disp(['Stop_loss = ', num2str(Stop_gain)]); %Choose how much gain we are willing to accept on a given pair, compared to 1, i.e 1.10 = 10% stop gain
    s1218 = 1; % listing req. (look ahead): 12+6 months (=1)

A1 = zeros(size(ddv_t,1),size(ddv_t,2)); 
A2 = zeros(size(ddu_t,1),size(ddu_t,2));
s1 = 0; s2 = 0;

lb = -0.65; ub = 0.65;

cloop = 1;

i = 1;

while cloop <= (Years * 2 -2) % big loop starts here; take 6 month steps
    Twe_mo = Periods(cloop,4); % picks up # of days in 12 months
    Six_mo = Periods(cloop+2,1); % picks up # of days in following 6 months
    il = Twe_mo;
    
        for pp = 1:no_pairs

            for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period

                s1 = cumsum(ddv_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A1(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s1;
                s2 = cumsum(ddu_t(il+1:j-i+1,...
                pp +100*(cloop-1)));
                A2(il+1:j-i+1,pp + no_pairs*(cloop-1)) = s2;
                
                intersec1 = intersect(find(s1<=lb),find(s2>=ub));
                intersec2 = intersect(find(s1>=0),find(s2<=0));
                intersec3 = intersect(find(s1>=ub),find(s2<=lb));
                intersec4 = intersect(find(s1<=0),find(s2>=0));                
                
                if (isempty(intersec1) == 1) && (isempty(intersec3) == 0)
                    pairs_opened = 1; % open pairs                    
                    if isempty(intersec4) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec4) == 0
                        pairs_opened = 1; % open pairs
                        if intersec4(end) > intersec3(1)
                            pairs_opened = 0;
                            il = il + intersec4(end);
                        end
                    end
                elseif (isempty(intersec3)== 1) && (isempty(intersec1)==0)
                    pairs_opened = -1; % open pairs                   
                    if isempty(intersec2) == 1 
                        pairs_opened = 0;
                    elseif isempty(intersec2) == 0
                        pairs_opened = -1; % open pairs
                        if intersec2(end) > intersec1(1)
                            pairs_opened = 0;
                            il = il + intersec2(end);
                        end
                    end
                elseif (isempty(intersec1) == 0) && (isempty(intersec3)==0)
                    if intersec1(1) < intersec3(1)
                        pairs_opened = -1; % open pairs                    
                        if isempty(intersec2) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec2) == 0
                            pairs_opened = -1; % open pairs
                            if intersec2(end) > intersec1(1)
                                pairs_opened = 0;
                                il = il + intersec2(end);
                            end
                        end                    
                    else
                        pairs_opened = 1; % open pairs                    
                        if isempty(intersec4) == 1 
                            pairs_opened = 0;
                        elseif isempty(intersec4) == 0
                            pairs_opened = 1; % open pairs
                            if intersec4(end) > intersec3(1)
                                pairs_opened = 0;
                                il = il + intersec4(end);
                            end
                        end
                    end
           
                end
            end
        end
        
    i = i + Periods(cloop,1);
    cloop = cloop + 1;

end % end main loop

    % ----------------------------------------------------
    % Reset several variables used for desc statistics
    % ----------------------------------------------------
    Av_price_dev = zeros(T-sum(Periods(1:2,1)),no_pairs*2); % 12 months are w/o price deviations
    % The first 12 months are formation period
    Rpair = zeros(sum(Periods(end-1,4)),no_pairs); % Keeps track of the return of each pair

    MDDpairs = zeros(length(Periods)-1,no_pairs); % Pre allocate MDD matrix for each pair out of sample;
    MDDw = zeros(length(Periods)-1,4); %- Preallocate MDD matrix out of sample for 4 weighting schemes.
                       % Rp_vw_cc, Rp_vw_fi, Rf, RmRf
    STNpairs = zeros(length(Periods)-2,no_pairs); % srt Ratio
    STNw = zeros(length(Periods)-2,4);

    periods_with_open_pair = 0; % number of periods with pairs opened
    periods_without_openpa = 0; % number of periods without pairs opened
    pairs_number = 0; pair_open = 0; %
    days_open = zeros(no_pairs*10000,1); % measures number of days each pair open; bad programming, but we do not know how many pairs we get
    no_pairs_opened = zeros(Years*2-2,no_pairs); % measures number of times pairs opened in each pair per 6 month period

    counter = 1; % Keeps track of the days in the main loop
    % ----------------------------------------------------
    % Start of Main Loop - Creating Price Index
    % ----------------------------------------------------
    % Main part of the program starts here
    % ----------------------------------------------------
    big_loop = 1;

    i = 1;

    while big_loop <= (Years * 2 -2); % big loop starts here; take 6 month steps
          Twe_mo = Periods(big_loop,4); % picks up # of days in 12 months
          Six_mo = Periods(big_loop+2,1); % picks up # of days in following 6 months
    % ----------------------------------------------------
    % Create price index IPt by setting first Pt>0 to 1
    % ----------------------------------------------------
    IPt = zeros(Twe_mo+Six_mo,N); % IPt = Indexed Price at time t
    % Preallocate a zeros matrix with the size of the Formation + Trading period
    % IPt = Indexed Price at time t

    for j=1:N
        m = 0;
        for i2=1:(Twe_mo+Six_mo)
            if Pt(i+i2-1,j)>0 && m == 0
                IPt(i2,j) = 1; m=1;
         elseif Pt(i+i2-1,j)>0 && m == 1
                IPt(i2,j) = IPt(i2-1,j) * (1 + Rt(i+i2-1,j));
            end
        end
    end

    listed1 = IPt(1,:) > 0; % listed at the beginning (1xN vector of 0/1s)
    listed2 = IPt(Twe_mo+Six_mo*(s1218==1),:)>0; % listed at the end: 12/18 months from now (1xN vector of 0/1s)
    listed = listed1 .* listed2; % listed throughout the 12+6 month period (1xN vector of 0/1s)

    no_listed = sum(listed);
    index_listed = find(listed>0); % find columns that should be included


    % These parts commented below are used in the paper which contains S&P 500 constituents
    % The constituents change along the periods.

    % [D,ia,ib]=intersect(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed= intersect(index_listed,ig');
    % no_listed = size(index_listed,2);

    % [D,ia,ib]=union(ticker2(:,big_loop),ticker2(:,big_loop+1));
    % [ic,id]= ismember(D,ticker2(:,big_loop+2));
    % [ie,ig]= ismember(D(ic),tickerb);
    % index_listed2 = ig';
    % no_listed2 = sum(ie);


    % ----------------------------------------------------
    % Add filters (if needed)
    % ----------------------------------------------------
    % e.g. remove if liquidity below value X, the second listed stock series etc.
    % ----------------------------------------------------
    % Desc stat of the price series
    % ----------------------------------------------------
    no_comp = sum((IPt > 0)')';

    disp(['Period ',num2str(big_loop)]);
    disp(['Time series mean no of stock series ',num2str(mean(no_comp))]);
    disp(['Max number of stock series ',num2str(max(no_comp))]);
    disp(['Min number of stock series ',num2str(min(no_comp))]);
    % ----------------------------------------------------
    % Calc SSEs
    % ----------------------------------------------------

    SSE = zeros(no_listed,no_listed);
        for j=1:(no_listed-1) % calculate SSE for all pairs
            for k=(j+1):no_listed % can prob. be speeded up by better programming
                % SSE(index_listed(j),index_listed(k)) = sum(abs( IPt(1:Twe_mo,index_listed(j))- IPt(1:Twe_mo,index_listed(k)) ));
               SSE(index_listed(j),index_listed(k)) = sum(( IPt(1:Twe_mo,index_listed(j))-...
                    IPt(1:Twe_mo,index_listed(k)) ).^2);
            end
        end


    % ----------------------------------------------------
    % Find min SSEs
    % ----------------------------------------------------
    max_SSE = max(max(SSE)) + 1;
    min_SSE = zeros(no_pairs,1);
    min_SSE_ro = zeros(1,no_pairs);
    min_SSE_co = zeros(1,no_pairs);

        for ii=1:no_pairs % find no_pairs minimum SSEs
            t_SSE = max_SSE; % temp_SSE

            for j=1:(no_listed-1)
                    for k=(j+1):no_listed
                        if SSE(j,k) > 0 && SSE(j,k) < t_SSE
                            t_SSE = SSE(j,k); % a new minimum is found
                        end
                    end
            end

            if t_SSE == max_SSE
                disp('ERROR---------------');
            end
    [ro,co] = find(SSE == t_SSE);   % row and column of the minimum
                                    % If there is a risk that the same asset is twice
                                    % in the database, add ro=ro(1) and co=co(1)
    ro=ro(1); co=co(1);

    min_SSE(ii,1) = SSE(ro,co);
    min_SSE_ro(ii) = ro; % column of the 1st stock in a pair
    min_SSE_co(ii) = co; % column of the 2nd stock in a pair
    SSE(ro,co) = max_SSE; % prevent re-selection

        end % of ii

    disp([min_SSE_ro;min_SSE_co]);

    % ----------------------------------------------------
    % Calculate returns during the 6 month period
    % ----------------------------------------------------
    count_temp = counter;

    for p=1:no_pairs
        counter = count_temp; pairs_opened = 0; new_pairs_opened = 0; lag = 0;
        std_limit = std(IPt(1:Twe_mo,min_SSE_ro(p))-IPt(1:+Twe_mo,min_SSE_co(p)));
    % Fixed volatility estimated in the 12 months period. Doing the calculation one pair at a time 
    Rcum = zeros(Twe_mo,1); counter_ret = 1; Rcum_ret = 1; % Presets all variables for each pair

    for j=(i+Twe_mo):(i+Twe_mo+Six_mo-1) % portfolio period
    % Defining the period as from the first day of the twe_month to the 
    % last day of the twe_month

    if daylag == 0 % w/o one day delay
            if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
                                  % If a sign to open has been given, then calcule the returns
               Rpair(counter,p) = +Rt(j,min_SSE_ro(p)) .* wi(1)- Rt(j,min_SSE_co(p)) .* wi(2);
               % Rpair is the return of each pair.
               Rcum(counter_ret,1) = Rpair(counter,p); 
               counter_ret = counter_ret + 1;
               Rcum_ret = cumprod(1+Rcum);  
               lag = lag + 1; %used for paying tc    

            if wi_update == 1 % The weight of each asset in the pair is updated. 
                            wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                            wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
                   Rpair(counter,p) = -Rt(j,min_SSE_ro(p)) .* wi(1) + Rt(j,min_SSE_co(p)) .* wi(2);
                   Rcum(counter_ret,1) = Rpair(counter,p); 
                   counter_ret = counter_ret + 1;
                   Rcum_ret = cumprod(1+Rcum);
                   lag = lag + 1;

            if wi_update == 1
                       wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                       wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
            else
                   Rpair(counter,p) = 0; % closed (this code not necessary)
            end

                if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
                   || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain) ...
                   || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))
                   
                    pairs_opened = 0; % close pairs: prices cross
                    lag = 0; % when pair is closed reset lag (it serves for paying tc)
                    Av_price_dev(counter,no_pairs+p) = 1; % add a marker for closing; 
                                                          % used to calc length of the "open-period"
                    Rpair(counter,p) = Rpair(counter,p) - C; %Includes trading cost in the last day of trading, due to closing position                                      
                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
                if pairs_opened == 0 % record dev (and time) at open
                    Rcum = zeros(Six_mo,1);
                    counter_ret = 1;
                    Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
                                              /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
                end

                pairs_opened = 1; % open pairs
                lag = lag + 1;  %- Lag was 0. On the next loop C will be paid
                wi = ones(1,2);

                elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)

            if pairs_opened == 0 % record dev (and time) at open
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
               Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))...
                                        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
            end

            pairs_opened = -1; % open pairs
            lag = lag + 1;
            wi = ones(1,2);

                end

            counter = counter + 1; % This is done for the first day, now update 
                                   % counter so it is done for the 2nd day        
            elseif daylag == 1 % w/one day delay

    if pairs_opened == -1 % pairs opened: long 1st, short 2nd stock
        Rpair(counter,p) = (+Rt(j,min_SSE_ro(p)) * wi(1) - Rt(j,min_SSE_co(p))* wi(2)) - (lag==2)*trading_cost;
        Rcum (counter_ret,1) = Rpair(counter,p); 
        counter_ret = counter_ret + 1;
        Rcum_ret = cumprod(1+Rcum);
    if wi_update == 1
        wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
        wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
    end

    elseif pairs_opened == 1 % pairs opened: short 1st, long 2nd stock
            Rpair(counter,p) = (-Rt(j,min_SSE_ro(p)) * wi(1)+ Rt(j,min_SSE_co(p)) * wi(2)) - (lag==2)*trading_cost;
            Rcum (counter_ret,1) = Rpair(counter,p); 
            counter_ret = counter_ret + 1;
            Rcum_ret = cumprod(1+Rcum);
            if wi_update == 1
                wi(1)=wi(1)*(1+Rt(j,min_SSE_ro(p)));
                wi(2)=wi(2)*(1+Rt(j,min_SSE_co(p)));
            end
    else
        Rpair(counter,p) = 0; % closed (this code not necessary)
    end

        pairs_opened = new_pairs_opened;

    if  (pairs_opened == +1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) <= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))>=0)...
       || Rcum_ret(end,1) <= Stop_loss || (Rcum_ret(end,1) >= Stop_gain)...   
       || pairs_opened == -1 && (A1(j-i+1,p + no_pairs*(big_loop-1)) >= 0) && (A2(j-i+1,p + no_pairs*(big_loop-1))<=0))

        new_pairs_opened = 0; % close prices: prices cross
        % If the pairs are open and the spread is smaller than the
        % threshold, close the position 
        lag = 0;
        Av_price_dev(counter+1,no_pairs+p) = 1; % see above, marker

        if wi_update == 1
            Rpair(counter,p) = Rpair(counter,p) - trading_cost - C;
        end

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) >= ub) && (A2(j-i+1,p + no_pairs*(big_loop-1)) <= lb)
            new_pairs_opened = 1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 1st, long 2nd) 
            lag = lag + 1;
            if  pairs_opened == 0
                Rcum = zeros(Six_mo,1);
                counter_ret = 1;
            end         

    elseif (A1(j-i+1,p + no_pairs*(big_loop-1)) <= lb) && (A2(j-i+1,p + no_pairs*(big_loop-1)) >= ub)
            new_pairs_opened = -1; % open pairs
            % If the difference between the prices are larger than 
            % the limit, and there is volume, open the position (short 2nd, long 1st)       
            lag = lag + 1;
            if pairs_opened == 0 % - If the pair was closed, reset accumulated return matrix and counter
               Rcum = zeros(Six_mo,1);
               counter_ret = 1;
            end
    end

    if new_pairs_opened == +1 && lag == 1
        Av_price_dev(counter,p) = 2*(+IPt(j-i+1,min_SSE_ro(p))- IPt(j-i+1,min_SSE_co(p)))...
        /(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);

    elseif new_pairs_opened == -1 && lag == 1

    Av_price_dev(counter,p) = 2*(-IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)))/(IPt(j-i+1,min_SSE_ro(p))+ IPt(j-i+1,min_SSE_co(p)));
        lag = lag + 1;
        wi = ones(1,2);
    end
        counter = counter + 1;
    end % endif of one day lag (0/1)
    end % end for pairs-period days (j)

    % if a pair open at the end, add a sign that closed
    % otherwise no additional steps necessary, as closing just gets last day's return

    if pairs_opened ~= 0
        Rpair(counter-1,p) = Rpair(counter-1,p) - trading_cost - C; %Includes trading cost in the last day of trading, due to closing position
        Av_price_dev(counter-1,no_pairs+p) = 1;
    end

    end % end for portfolio (p)
    %% Using 2 Weighting Schemes - Fully Invested and Committed Capital
    % ------------------------------------------------------------
    % Calculate portfolio returns (ew, vw) out of percentage Rpair
    % ------------------------------------------------------------
    Rpair_temp = Rpair(counter-Six_mo:counter-1,:);
    %
    % eq-weighted average on committed cap.; weights reset to "one" (or any equal weight) after each day
    %
    Ret_acum_pairs(counter-Six_mo:counter-1,:) = (cumprod(1+(Rpair_temp)));
    [MaxDD,~] = maxdrawdown(ret2tick(Rpair_temp));
    MDDpairs(big_loop,:)= MaxDD;  
    STN = sortinoratio(Rpair_temp,0);
    STNpairs(big_loop,:) = STN;

    %
    wi = ones(1,no_pairs);
    wi = [wi;cumprod(1+Rpair_temp)];
    wi = wi(1:Six_mo,:);
    %
    % vw-weighted, committed cap.; weights "restart" every 6 month period; 
    % (each portfolio gets 1 dollar at the beginning)
    Rp_vw_cc(counter-Six_mo:counter-1,:) = (sum((wi .* Rpair_temp)'))' ./ sum(wi')';
    %
    % vw-weighted, fully invested; weights "restart" from 1 every time a new pair is opened;
    % Capital divided between open portfolios.
    Ret_acum(counter-Six_mo:counter-1,2) = (cumprod(1+(Rp_vw_cc(counter-Six_mo:counter-1,:))));
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_cc(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,2) = MaxDD;
    STN = sortinoratio(Rp_vw_cc(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,2) = STN;
    %
    pa_open = zeros(Six_mo,no_pairs); % indicator for days when pairs open

        for i2=1:no_pairs
            pa_opened_temp = 0;temp_lag = 0;
        for i1=1:Six_mo
            if  pa_opened_temp == 1 && daylag == 0 % opening period not included, closing included
                pa_open(i1,i2) = 1;
                days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end
            if   pa_opened_temp == 1 && daylag == 1 && temp_lag == 1
                 pa_open(i1,i2) = 1;
                 days_open(pairs_number,1) = days_open(pairs_number,1) + 1;
            end

            if  pa_opened_temp == 1 && daylag == 1 && temp_lag == 0
                temp_lag = 1;
            end

            if  Av_price_dev(counter-1-Six_mo+i1,i2) ~= 0
                pa_opened_temp = 1;
                pairs_number = pairs_number + 1;
            end

             if  Av_price_dev(counter-1-Six_mo+i1,no_pairs+i2) ~= 0
                 pa_opened_temp = 0;
                 temp_lag = 0;
             end
        end
        end

    wi2 = wi .* pa_open;

    for i2=1:Six_mo % takes care in a situation where no pairs are open
        if  sum(pa_open(i2,:)') == 0
            wi2(i2,1:no_pairs) = 0.2 * ones(1,no_pairs);
            pa_open(i2,1:no_pairs) = ones(1,no_pairs);
        end
    end

    Rp_vw_fi(counter-Six_mo:counter-1,:) = (sum((wi2 .* Rpair_temp)'))' ./ sum(wi2')';

    Ret_acum(counter-Six_mo:counter-1,3) = (cumprod(1+(Rp_vw_fi(counter-Six_mo:counter-1,:))));
    %
    [MaxDD,~] = maxdrawdown(ret2tick(Rp_vw_fi(counter-Six_mo:counter-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(Rp_vw_fi(counter-Six_mo:counter-1,:),0);
    STNw(big_loop,4) = STN;
    %
    %
    Ret_acum(i:i+Six_mo-1,5) = (cumprod(1+(RmRf(i:i+Six_mo-1,:))));
    [MDD,MDDIndex] = maxdrawdown(ret2tick(RmRf(i:i+Six_mo-1,:)));
    MDDw(big_loop,4) = MaxDD;
    STN = sortinoratio(RmRf(i:i+Six_mo-1,:),0);
    STNw(big_loop,4) = STN;

        for i2=1:no_pairs
            if  sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0) ~= 0
                periods_with_open_pair = periods_with_open_pair + 1;
                no_pairs_opened(big_loop,i2) = no_pairs_opened(big_loop,p)+ sum(Av_price_dev(counter-Six_mo:counter-1,i2) ~= 0);
            else

            periods_without_openpa = periods_without_openpa + 1;
            end
        end

    i = i + Periods(big_loop,1);

    big_loop = big_loop + 1;

    end % end main loop
% ----------------------------------------------------
% ************* Analysis of the results **************
% ----------------------------------------------------
T_Rp = size(Rp_vw_cc,1); T_RmRf = size(RmRf,1);
Rf = Rf((1+T_RmRf-T_Rp):T_RmRf,1); % risk-free rate
% RmRf excess market

RmRf = RmRf((1+T_RmRf-T_Rp):T_RmRf,1);
SMB = SMB((1+T_RmRf-T_Rp):T_RmRf,1); HML = HML((1+T_RmRf-T_Rp):T_RmRf,1);
WML = WML((1+T_RmRf-T_Rp):T_RmRf,1); IML = IML((1+T_RmRf-T_Rp):T_RmRf,1);

Ret_vw = [Rp_vw_cc, Rp_vw_fi, Rf, RmRf];

T_Rp

% Descriptives
%	    1st row: geometric mean
%		2nd row: standard deviation
%		3rd row: coefficient for the skewnewss
%		4th row: coefficient for the degree of excess kurtosis
desc2a= stat2(1+Rp_vw_cc,1,3,0); desc2b= stat2(1+Rp_vw_fi,1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf 1+RmRf],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);
  
% Max DrawDown 2 days 
for j=1:1474 % 1:dimension Rp_vw -1
    MaxDD2_vw_cc(j)= (1+Rp_vw_cc(j,:))*(1+Rp_vw_cc(j+1,:)); 
    MaxDD2_vw_fi(j)= (1+Rp_vw_fi(j,:))*(1+Rp_vw_fi(j+1,:));
    MaxDD2_Rm_Rf(j)= (1+RmRf(j,:))*(1+RmRf(j+1,:));
end

% worst drawdown
MDD2_vw_cc= min(MaxDD2_vw_cc); MDD2_vw_fi= min(MaxDD2_vw_fi);
MDD2_Rm_Rf= min(MaxDD2_Rm_Rf);

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc,col_vw_cc]= min(MaxDD2_vw_cc);
[row_vw_fi,col_vw_fi]= min(MaxDD2_vw_fi);
[row_RmRf,col_RmRf]= min(MaxDD2_Rm_Rf);

% Max DrawDown 6 months
for i=1:1349 % 1:dimension Rp_vw -126 (6 months)
    MaxDD_vw_cc(i,:)= cumprod(1+Rp_vw_cc(i:i+126-1,:));
    MaxDD_vw_fi(i,:)= cumprod(1+Rp_vw_fi(i:i+126-1,:));
    MaxDD_Rm_Rf(i,:)= cumprod(1+RmRf(i:i+126-1,:));
end

% Not that relevant. I'm just curious to know where the the MaxDD has
% occurred
[row_vw_cc6m,col_vw_cc6m]= min(min(MaxDD_vw_cc));
[row_vw_fi6m,col_vw_fi6m]= min(min(MaxDD_vw_fi));
[row_RmRf6m,col_RmRf6m]= min(min(MaxDD_Rm_Rf));

% srt Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Regress each series on the constant
[~,t_vw_cc] = alpha_factor_model(Rp_vw_cc,ones(size(Rp_vw_cc,1),1),0,6);
[~,t_vw_fi] = alpha_factor_model(Rp_vw_fi,ones(size(Rp_vw_fi,1),1),0,6);
[~,t_bench] = alpha_factor_model(RmRf,ones(size(RmRf,1),1),0,6);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: t-stat
%	    5th row: % of negative trades
%		6th row: MDD1
%		7th row: MDD2
%		8th row: Annualized Std. Dev (%)
%		9th row: Skewness
%		10th row: Kurtosis
%		11st row: Minimum Daily Return (%)
%		12nd row: Maximum Daily Return (%)
%		13rd row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     t_vw_cc, 100*(sum([Rp_vw_cc]<0)/size(Rp_vw_cc,1)), 100*(1-MDD2_vw_cc),...
     100*(1-min(min(MaxDD_vw_cc))), 100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     t_vw_fi, 100*(sum(Rp_vw_fi<0)/size(Rp_vw_fi,1)), 100*(1-MDD2_vw_fi),...
     100*(1-min(min(MaxDD_vw_fi))), 100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     t_bench, 100*(sum(RmRf<0)/size(RmRf,1)), 100*(1-MDD2_Rm_Rf),...
     100*(1-min(min(MaxDD_Rm_Rf))), 100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    

VariableNames1 = {'VW_CC','VW_FI','Benchmark'};
RowNames1 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';'t-stat';...
    'Share of negative excess returns';'MDD1';'MDD2'; 'Annualized Std Dev (%)'; 'Skewness';...
    'Kurtosis'; 'Minimum Daily Return (%)'; 'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table1 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames1,'RowNames',RowNames1);

no_pairs_open = sum(sum(no_pairs_opened)'); x = sum(abs(Av_price_dev(:,1:no_pairs)) > 0);
days_open = days_open(1:no_pairs_open,1);

VariableNames2 = {'Trading_Statistics'};
RowNames2 = {'Av_Price_Dev_trigger_openpa';'Total_number_of_pairs_opened';...
    'Average_number_of_pairs_opened_per_six-month_period'; ...
    'Average_number_of_round-trip_trades_per_pair_in_months'; 'Standard_Dev';'Average_time_pairs_are_open_in_days';...
    'Standard_Deviation';'Median_time_pairs_are_open_in_days'};

trading_stat=[sum(sum(abs(Av_price_dev(:,1:no_pairs)))')./sum((sum(abs(Av_price_dev(:,1:no_pairs)) >.0))'),...
    no_pairs_open,no_pairs_open/(big_loop-1),...
    mean(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),...
    std(reshape(no_pairs_opened,no_pairs*(big_loop-1),1)),mean(days_open),std(days_open),median(days_open)];
table2 = table(trading_stat',...
    'VariableNames',VariableNames2,'RowNames',RowNames2);

ff5 = [RmRf,SMB,HML,WML,IML]; ff5_vw_cc= [Rp_vw_cc, ff5]; % Fama-French 5 factors

vw_ff5 = ff5_vw_cc(:,2:6);

% nwlags = 6
[beta_vw_cc_ff5,se_vw_cc_ff5,t_vw_cc_ff5] = beta_factor_model(Rp_vw_cc,vw_ff5,6);
[beta_vw_fi_ff5,se_vw_fi_ff5,t_vw_fi_ff5] = beta_factor_model(Rp_vw_fi,vw_ff5,6);

fit_vw_cc = fitlm(vw_ff5,Rp_vw_cc); fit_vw_fi = fitlm(vw_ff5,Rp_vw_fi);

ff5_vw_cc = [beta_vw_cc_ff5(1).*100,t_vw_cc_ff5(1),beta_vw_cc_ff5(2).*100,t_vw_cc_ff5(2),...
             beta_vw_cc_ff5(3).*100,t_vw_cc_ff5(3),beta_vw_cc_ff5(4).*100,t_vw_cc_ff5(4),...
             beta_vw_cc_ff5(5).*100,t_vw_cc_ff5(5),beta_vw_cc_ff5(6).*100,t_vw_cc_ff5(6),...
             fit_vw_cc.Rsquared.Ordinary,fit_vw_cc.Rsquared.Adjusted];
ff5_vw_fi = [beta_vw_fi_ff5(1).*100,t_vw_fi_ff5(1),beta_vw_fi_ff5(2).*100,t_vw_fi_ff5(2),...
             beta_vw_fi_ff5(3).*100,t_vw_fi_ff5(3),beta_vw_fi_ff5(4).*100,t_vw_fi_ff5(4),...
             beta_vw_fi_ff5(5).*100,t_vw_fi_ff5(5),beta_vw_fi_ff5(6).*100,t_vw_fi_ff5(6),...
             fit_vw_fi.Rsquared.Ordinary,fit_vw_fi.Rsquared.Adjusted];
    
disp(' ');
VariableNames3 = {'VW_CC','VW_FI'};
RowNames3 = {'Intercept';'t_alpha';'Market';'t_beta';'SMB';'t_SMB';'HML';'t_HML';...
    'WML';'t_WML';'IML';'t_IML';'R2';'R2adj'};
table3 = table(ff5_vw_cc',ff5_vw_fi',...
         'VariableNames',VariableNames3,'RowNames',RowNames3);
 
writetable(table1,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',1);
writetable(table2,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',2);
writetable(table3,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',3);
 
% Sub-period Analysis
% sum(Periods(3:14,1)), % sum(Periods(3:8,1))
% # 1475, 739 (Do the same calculation for 1:739 and 740:1475).
% I kept the names. If you feel confused add new ones for the 1st (1:739) and the
% 2nd subperiods (observations 740 to 1475).
desc2a= stat2(1+Rp_vw_cc(1:739,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(1:739,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(1:739,1) 1+RmRf(1:739,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
 
VariableNames4 = {'VW_CC_sub1','VW_FI_sub1','Benchmark_sub1'};
RowNames4 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table4 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames4,'RowNames',RowNames4);

writetable(table4,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',4);
    
desc2a= stat2(1+Rp_vw_cc(740:1475,1),1,3,0); desc2b= stat2(1+Rp_vw_fi(740:1475,1),1,3,0); 
desc2= [desc2a desc2b]; desc3= stat2([1+Rf(740:1475,1) 1+RmRf(740:1475,1)],1,3,0);

% Sharpe Ratio
SR_vw_cc= sqrt(252)*desc2(1,1)./desc2(2,1); SR_vw_fi= sqrt(252)*desc2(1,2)./desc2(2,2); 
SR_Rm_Rf = sqrt(252)*desc3(1,2)./desc3(2,2);

% Sortino Ratio
% 0 is level of minimum acceptable return (MAR). It could be Rf.
srt_vw_cc= sqrt(252)*sortinoratio(Rp_vw_cc,0);
srt_vw_fi= sqrt(252)*sortinoratio(Rp_vw_fi,0);
srt_Rm_Rf= sqrt(252)*sortinoratio(RmRf,0);

% Table 1: Excess returns of distance strategy
%	    1st row: Annualized Mean Return (%)
%		2nd row: Sharpe Ratio
%		3rd row: Sortino Ratio
%		4th row: Annualized Std. Dev (%)
%		5th row: Skewness
%		6th row: Kurtosis
%		7th row: Minimum Daily Return (%)
%		8th row: Maximum Daily Return (%)
%		9th row: Cumulative Excess Return
ds_vw_cc = [100*((1+desc2(1,1)).^252-1), SR_vw_cc, srt_vw_cc,...
     100*((1+desc2(1,1)).^252-1)/SR_vw_cc, desc2(3,1), desc2(4,1),...
     100*min(Rp_vw_cc), 100*max(Rp_vw_cc), (1+desc2(1,1))^T_Rp];
 
ds_vw_fi = [100*((1+desc2(1,2)).^252-1), SR_vw_fi, srt_vw_fi,...
     100*((1+desc2(1,2)).^252-1)/SR_vw_fi, desc2(3,2), desc2(4,2),...
     100*min(Rp_vw_fi), 100*max(Rp_vw_fi), (1+desc2(1,2))^T_Rp];
 
 ds_Rm_Rf= [100*((1+desc3(1,2)).^252-1), SR_Rm_Rf, srt_Rm_Rf,...
     100*((1+desc3(1,2)).^252-1)/SR_Rm_Rf, desc3(3,2), desc3(4,2),...
     100*min(RmRf), 100*max(RmRf), (1+desc3(1,2))^T_Rp];    
     
VariableNames5 = {'VW_CC_sub2','VW_FI_sub2','Benchmark_sub2'};
RowNames5 = {'Annualized Mean Return (%)';'Sharpe_Ratio';'Sortino Ratio';...
    'Annualized Std Dev (%)'; 'Skewness';'Kurtosis'; 'Minimum Daily Return (%)';...
    'Maximum Daily Return (%)'; 'Cumulative Excess Return'};
table5 = table(ds_vw_cc',ds_vw_fi',ds_Rm_Rf',...
    'VariableNames',VariableNames5,'RowNames',RowNames4);

writetable(table5,'C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c2.xlsx','WriteVariableNames',true,...
        'WriteRowNames',true,'Sheet',5);
  
% saving the .mat file
save('C:\Users\fsabino\Desktop\Matlab\Pairs Trading High Frequency\results\garch\garch_b65p100c2.mat');      

    